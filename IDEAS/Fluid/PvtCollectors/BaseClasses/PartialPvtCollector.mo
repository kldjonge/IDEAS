within IDEAS.Fluid.PvtCollectors.BaseClasses;
model PartialPvtCollector
  "Extended partial solar (thermal) collector with discretized PV electrical calculations"
  extends IDEAS.Fluid.SolarCollectors.BaseClasses.PartialSolarCollector(
      redeclare IDEAS.Fluid.PvtCollectors.Data.GenericQuasiDynamic per);

  // =====  Parameters =====
  final parameter Modelica.Units.SI.Irradiance Gstc = 1000
    "Irradiance at Standard Conditions (W/m2)";
  parameter Modelica.Units.SI.Efficiency   pLossFactor = 0.10
    "Loss factor of the PV panel(s)" annotation(Dialog(group="Electrical parameters"));
  constant Modelica.Units.SI.Temperature _T_ref = 25 + 273
    "Reference cell temperature (K)";
  parameter IDEAS.Fluid.PvtCollectors.Types.CollectorType collectorType =
  IDEAS.Fluid.PvtCollectors.Types.CollectorType.Uncovered
    "Type of collector (used to select (tau*alpha)_eff)";
  parameter Real tauAlphaEff =
    if collectorType == IDEAS.Fluid.PvtCollectors.Types.CollectorType.Uncovered then 0.901 else 0.84
    "Effective transmittanceâ€“absorptance product";
  output Modelica.Units.SI.CoefficientOfHeatTransfer UAbsFluidCalc =
  ((tauAlphaEff - per.eta0El) * (per.c1 + abs(per.gamma)*Gstc))
  / ((tauAlphaEff - per.eta0El) - per.eta0)
  "Heat transfer coefficient calculated from datasheet parameters";

  // ===== Variables  =====

  Real Tm[nSeg]         "Mean fluid temperature for each segment";
  Real temCell[nSeg]     "Cell temperature for each segment (K)";
  Real temDiff[nSeg]     "Temperature difference of the cell relative to reference (K)";
  Real G                "Global irradiance on the panel (W/m2)";
  Real qth[nSeg]        "Thermal power density per segment [W/m2]";
  Real temMod     "Average cell temperature";
  Real temMea     "Average fluid temperature";


  // ===== Real Output Connectors =====
  Modelica.Blocks.Interfaces.RealOutput pel
    "Electrical power generated by the photovoltaic installation"
    annotation(Placement(transformation(extent={{100,70},{120,90}}),
        iconTransformation(extent={{100,70},{120,90}})));
  Modelica.Blocks.Interfaces.RealOutput qTh
    "Total thermal power generated by the PVT installation"
    annotation(Placement(transformation(extent={{100,-90},{120,-70}})));

   Modelica.Blocks.Interfaces.RealOutput solarPowerInternal[nSeg]
  "Electrical power produced by each discretized PV segment (W)";
  Modelica.Blocks.Math.Add gGlob "Total irradiation on tilted surface"
    annotation (Placement(transformation(
        extent={{10,-10},{-10,10}},
        rotation=90,
        origin={24,78})));
equation
  // Directly calculate global irradiance from measurement data
  G =gGlob.y;

  // Calculate PV electrical performance for each segment
  for i in 1:nSeg loop
    // Retrieve the mean fluid temperature from the sensor array (provided by the base model)
    Tm[i] = temSen[i].T;
    // Compute the local thermal power density (W/m2)
    qth[i] = (QGai[i].Q_flow + QLos[i].Q_flow) / (ATot_internal/nSeg);
    // Estimate the cell temperature using fluid temperature and thermal flux
    temCell[i] = Tm[i] + qth[i] / UAbsFluidCalc;
    // Determine the temperature difference relative to the reference temperature
    temDiff[i] = temCell[i] - _T_ref;
    // Calculate electrical power output per segment using the PV performance equation
    solarPowerInternal[i] = (ATot_internal/nSeg) * (per.Pstc/per.A) * (G/Gstc) *
                         (1 + per.gamma*temDiff[i]) * (1 - pLossFactor);

  end for;

  // Assign the sum of the segment electrical outputs to the output connector pel
  pel = sum(solarPowerInternal);

  // Calculate the total thermal power by multiplying the thermal density with the segment area and summing up
  qTh = (ATot_internal/nSeg) * sum(qth);

  // Calculate the average cell temperature, defined as module temperature
  temMod = sum(temCell)/nSeg;

  // Calculate the average fluid temperature, defined as module temperature
  temMea = sum(Tm)/nSeg;

  connect(gGlob.u1, HDirTil.H) annotation (Line(points={{18,90},{-54,90},{-54,50},
          {-59,50}}, color={0,0,127}));
  connect(gGlob.u2, HDifTilIso.H) annotation (Line(points={{30,90},{30,98},{-54,
          98},{-54,92},{-56,92},{-56,80},{-59,80}}, color={0,0,127}));
end PartialPvtCollector;
